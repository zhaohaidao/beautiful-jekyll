---
layout: post
title: Lamport Clock
---
# 摘要
paxos算法作者lamport 1978年的作品Time, Clocks, and the Ordering of Events in a Distributed System是分布式系统领域引用量最大的一篇论文，对分布式系统的发展影响深远。本文就以下几点进行了详细阐述
+ 引入了happened-before定义事件间的偏序关系
+ 引入了逻辑时钟捕捉事件间的happened-before关系
+ 通过扩展逻辑时钟，定义事件间的全序关系（totally order）
+ 通过totally order解决同步问题(synchronization problems)
+ 描述逻辑时钟有可能存在未定义行为
+ 引入物理时钟解决未定义行为，并描述物理时钟需要满足的约束

# 偏序
大多数人使用物理时钟描述事件间的happened-before关系，但是物理时钟不完全准确，且不能精确的反应物理时间，因此本文定义不基于物理时钟的happened-before关系。

作者如此定义了不基于物理时钟的系统：系统由一组进程组成，每个进程都包含一系列事件。假设接收或者发送消息是进程的事件，然后就可以定义happened-before关系了，"->" 即 "happened-before"。
+ 如果a和b是同一个进程的2个事件，且a先于b，则 a->b
+ 如果a是一个进程发送消息的事件，b是另一个进程接收该消息的事件，则a->b
+ 如果a->b，b->c，则a->c
+ 如果a-\\>b，且b-\\>a，则a和b被认为是并发的事件

# 逻辑时钟
定义完happened-before关系，接着作者开始引入逻辑时钟。从抽象的角度看，时钟其实是一种为事件分配数字的方式，其中数字代表事件发生的时间。更确切地说，我们为每个进程Pi定义时钟Ci，这里并没有假设和物理时间的关系，因此，可以将Ci视为逻辑时钟，而不是物理时钟。那么这样的系统如何保证正确性呢？系统的必须基于事件的顺序，那么最合理的条件就是：如果事件a发生在事件b之前，那么事件a应该在b更早的时间发生。正式的陈述如下：
+ 时钟条件-对于任何事件a，b，如果 a->b, 则C(a)<C(b)
    + C1-如果a和b是同一进程的事件，且a早于b，则C(a)<C(b)
    + C2-如果a是Pi的发送消息事件，b是Pj的接收该消息的事件，则C(a)<C(b)
+ 如何满足时钟条件
    + 每个进程在任意连续事件之间均递增C(i)
    + 如果a是进程Pi的发送消息事件，且时间戳是T(m)=C(a)，当进程Pj接收到该消息时，将调整C(b)满足条件：大于等于当前值且大于C(a) 

# 定义全序
根据偏序关系，我们很容易定义全序关系
+ a是Pi的事件，b是Pj的事件，当且仅当C(a)<C(b),或者C(a)=C(b),Pi<Pj
    + 为进程设置优先级解决时钟相等的场景 

# 利用全序关系解决资源争抢问题
我们希望找到一种算法解决资源争抢问题，资源授予需要满足以下三个条件：
+ I 资源被进程A持有时，只有被A释放时，才能授予给进程B
+ II 不同的请求必须按序批准
+ III 如果每个授予资源的进程最后均会释放该资源，那么每个资源请求都会得到处理

仔细思考就会发现，中心化调度无法实现按顺序授予，考虑以下场景，P0是调度进程
+ 假设P1向Po发送请求，然后向P2发送消息
+ P2收到P1发送的消息后，立即向P0发送请求
+ P2向P0发送的请求先于P1向P0发送的请求是有可能的，这将违背条件II

接着，我们来看看如何通过全序关系解决资源争抢问题。我们假设消息的接收顺序和发送顺序相同，并且消息最终都会被收到。首先，每个进程都会维护一个私有队列（应该不是一个FIFO队列，而是一个基于时间戳排序的优先级队列），该队列对其他进程不可见
1. 为了请求资源，Pi将消息Tm:Pi发送给每个其他进程，然后将消息放进自己的队列
2. 当进程Pj接收到消息Tm:Pi时，将它放进自己的队列，并向Pi发送一个带时间戳的ack
    + ack不是必须的，只要Pj发送给Pi一个时间戳大于Tm的消息即可
3. 为了释放资源，Pi从队列中移除Tm:Pi，并向其他进程发送带有时间戳的释放资源的消息
4. 当进程Pj接收到释放资源消息时，它将从队列中移除该消息
5. 当满足以下两个条件时，进程Pi将被授予该资源
    + I Pi的队列中存在该消息，并且该消息在队列的头部
    + II Pi收到了每个其他进程发送的时间戳晚于Tm的消息

算法分析：
+ 5.II以及消息有序假定保证了Pi已经收到了所有先于Tm的请求
    + 说明不存在有时间戳更小的请求还未发送到Pi
    + 如果有早于Tm的消息Tn由Pj发出，且Pi未收到，那么Pi就一定不会收到时间戳晚于Tm的回应
+ 由于3和4是唯一从队列中删除消息的规则，所以只要Pi不主动删除消息，消息一直位于队列头部，别的进程也就没办法申请到资源，因此条件I得到了保证
+ 由于全序关系扩展了偏序关系，（这句话的因果关系百思不得其解）因此条件II得到了保证
    + 队列是一个基于时间戳排序的优先级队列，能保证时间戳小的请求优先得到处理
+ 规则2保证了Pi在申请资源后，规则5.II最终将成立，规则3和4意味着每个获取资源的进程最终总会释放它，那么规则5.I最终将成立。因此条件III得到了保证

# 未定义行为
基于全序关系的资源调度算法有可能会出现Anomalous Behavior。假设在一个全国范围联网的计算机系统中
+ 一个人在计算机A发出请求e1，然后给另一个城市的朋友打电话让他在另一台计算机B上发送请求e2
+ 请求e2很可能会获取到一个更低的时间戳，并且排序时在e1之前
+ 系统无法知道e1实际上在e2之前，因为这个优先级信息是系统之外的信息

有两种方案可以避免Anomalous Behavior
+ 第一种方案：向系统引入必要的排序信息，发出请求e1的人可以指定时间戳T1，当发送请求e2时，可以指定e2的时间戳T2晚于T1
+ 第二种方案：构建满足以下条件的时钟系统
    + 强时钟条件. 任意事件a, b: if a --> b then C(a) < C(b)
    + -->是狭义相对论定义的偏序。基于物理时空构建的时钟系统将满足强时钟条件
    
# 物理时钟
在时空图中引入物理时间坐标，Ci(t)表示在物理时间t读取时钟Ci。假设时钟运行是连续而非离散（离散的时钟也可以被认为是连续的，只不过读取时会有高达1/2tick的误差）。更确切的说，Ci(t)是t的连续可微函数，dCg(t)/dt表示时钟的运行频率。为了让时钟Cg(t)成为真正的的物理时钟，必须保证dCg(t)/dt~=1。更确切的说，我们需要满足以下条件
+ PCI 存在常量 k << 1，对所有的满足: |dCi(t)/dt - 1| < k.
    + 单独的时钟以大约正确的速率运行是不够的，所有的时钟必须保持同步，也就是说对于任何i, j，需要保证Ci(t)~=Cj(t)
    + 更精确的说，需要有一个足够小的常数e，满足PCII
+ PCII 对所有的i，j，满足：|Ci(t) - Cj(t)|< e
    + 由于两个不同的时钟永远不会以相同的速率运行，因此他们的偏差会越来越大，必须设计一种算法保证PCII始终保持不变
    + 定义时钟误差为u，结合PCII和e/(1 - k) <= u， 即可推导出Ci(t+u) - Cj(t) > 0
    + e/(1 - k) <= u的证明略，详细证明可参考：http://loopjump.com/time_clock_order

接着lamport讲述了保证PCII保持不变的算法，不过算法描述和证明过程更加繁琐和复杂，此处不再延伸。

# 总结
除了最后物理时钟约束的证明过程之外，整篇论文还是比较容易理解的。本文中引入的逻辑时钟也受到了广泛使用，如consul、mysql等（用于捕捉事件间的因果关系）。不仅如此，分布式领域又涌现了vector clock、hibrid clock以及hibrid logical clock等逻辑时钟的变种，这些后继者虽然从不同层面解决了逻辑时钟的问题，却又引入了新的挑战。我将在后续篇章逐渐介绍他们。

